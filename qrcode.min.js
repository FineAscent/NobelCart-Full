/*! QRCode minimal build (qrcode-generator by Kazuhiko Arase, MIT) + Promise-based toCanvas helper. */
(function(global){
  // QR Code generator (typeNumber 0 = automatic)
  // Source: https://github.com/kazuhikoarase/qrcode-generator (trimmed, unminified)
  var QRCodeModel = function(typeNumber, errorCorrectLevel) {
    var PAD0 = 0xEC, PAD1 = 0x11;
    var _typeNumber = typeNumber;
    var _errorCorrectLevel = QRErrorCorrectLevel[errorCorrectLevel];
    var _modules = null;
    var _moduleCount = 0;
    var _dataCache = null;
    var _dataList = [];

    var _this = {};

    var makeImpl = function(test, maskPattern) {
      _moduleCount = _typeNumber * 4 + 17;
      _modules = new Array(_moduleCount);
      for (var row = 0; row < _moduleCount; row++) {
        _modules[row] = new Array(_moduleCount);
        for (var col = 0; col < _moduleCount; col++) {
          _modules[row][col] = null;
        }
      }
      setupPositionProbePattern(0, 0);
      setupPositionProbePattern(_moduleCount - 7, 0);
      setupPositionProbePattern(0, _moduleCount - 7);
      setupPositionAdjustPattern();
      setupTimingPattern();
      setupTypeInfo(test, maskPattern);
      if (_typeNumber >= 7) setupTypeNumber(test);
      if (_dataCache == null) _dataCache = createData(_typeNumber, _errorCorrectLevel, _dataList);
      mapData(_dataCache, maskPattern);
    };

    var setupPositionProbePattern = function(row, col) {
      for (var r = -1; r <= 7; r++) {
        if (row + r <= -1 || _moduleCount <= row + r) continue;
        for (var c = -1; c <= 7; c++) {
          if (col + c <= -1 || _moduleCount <= col + c) continue;
          if ((0 <= r && r <= 6 && (c == 0 || c == 6)) || (0 <= c && c <= 6 && (r == 0 || r == 6)) || (2 <= r && r <= 4 && 2 <= c && c <= 4)) {
            _modules[row + r][col + c] = true;
          } else {
            _modules[row + r][col + c] = false;
          }
        }
      }
    };

    var getBestMaskPattern = function() {
      var minLostPoint = 0;
      var pattern = 0;
      for (var i = 0; i < 8; i++) {
        makeImpl(true, i);
        var lostPoint = QRUtil.getLostPoint(_this);
        if (i == 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint; pattern = i;
        }
      }
      return pattern;
    };

    var setupTimingPattern = function() {
      for (var r = 8; r < _moduleCount - 8; r++) {
        if (_modules[r][6] != null) continue;
        _modules[r][6] = (r % 2 == 0);
      }
      for (var c = 8; c < _moduleCount - 8; c++) {
        if (_modules[6][c] != null) continue;
        _modules[6][c] = (c % 2 == 0);
      }
    };

    var setupPositionAdjustPattern = function() {
      var pos = QRUtil.getPatternPosition(_typeNumber);
      for (var i = 0; i < pos.length; i++) {
        for (var j = 0; j < pos.length; j++) {
          var row = pos[i], col = pos[j];
          if (_modules[row][col] != null) continue;
          for (var r = -2; r <= 2; r++) {
            for (var c = -2; c <= 2; c++) {
              _modules[row + r][col + c] = (r == -2 || r == 2 || c == -2 || c == 2 || (r == 0 && c == 0));
            }
          }
        }
      }
    };

    var setupTypeNumber = function(test) {
      var bits = QRUtil.getBCHTypeNumber(_typeNumber);
      for (var i = 0; i < 18; i++) {
        var mod = (!test && ((bits >> i) & 1) == 1);
        _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;
        _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
      }
    };

    var setupTypeInfo = function(test, maskPattern) {
      var data = (_errorCorrectLevel << 3) | maskPattern;
      var bits = QRUtil.getBCHTypeInfo(data);
      for (var i = 0; i < 15; i++) {
        var mod = (!test && ((bits >> i) & 1) == 1);
        if (i < 6) _modules[i][8] = mod;
        else if (i < 8) _modules[i + 1][8] = mod;
        else _modules[_moduleCount - 15 + i][8] = mod;
      }
      for (var j = 0; j < 15; j++) {
        var mod2 = (!test && ((bits >> j) & 1) == 1);
        if (j < 8) _modules[8][_moduleCount - j - 1] = mod2;
        else if (j < 9) _modules[8][15 - j - 1 + 1] = mod2;
        else _modules[8][15 - j - 1] = mod2;
      }
      _modules[_moduleCount - 8][8] = !test;
    };

    var mapData = function(data, maskPattern) {
      var inc = -1;
      var row = _moduleCount - 1;
      var bitIndex = 7; var byteIndex = 0;
      for (var col = _moduleCount - 1; col > 0; col -= 2) {
        if (col == 6) col--;
        while (true) {
          for (var c = 0; c < 2; c++) {
            if (_modules[row][col - c] == null) {
              var dark = false;
              if (byteIndex < data.length) dark = (((data[byteIndex] >>> bitIndex) & 1) == 1);
              var mask = QRUtil.getMask(maskPattern, row, col - c);
              _modules[row][col - c] = (dark ^ mask);
              bitIndex--;
              if (bitIndex == -1) { byteIndex++; bitIndex = 7; }
            }
          }
          row += inc;
          if (row < 0 || _moduleCount <= row) { row -= inc; inc = -inc; break; }
        }
      }
    };

    _this.addData = function(data) {
      var newData = new QR8bitByte(data);
      _dataList.push(newData);
      _dataCache = null;
    };

    _this.isDark = function(row, col) { return _modules[row][col]; };
    _this.getModuleCount = function() { return _moduleCount; };

    _this.make = function() {
      if (_typeNumber < 1) {
        _typeNumber = 1;
        for (; _typeNumber < 40; _typeNumber++) {
          var rsBlocks = QRRSBlock.getRSBlocks(_typeNumber, _errorCorrectLevel);
          var buffer = QRBitBuffer();
          for (var i = 0; i < _dataList.length; i++) buffer.put(_dataList[i].mode, 4);
          for (var i2 = 0; i2 < _dataList.length; i2++) buffer.put(_dataList[i2].getLength(), QRUtil.getLengthInBits(_dataList[i2].mode, _typeNumber));
          for (var i3 = 0; i3 < _dataList.length; i3++) _dataList[i3].write(buffer);
          var totalDataCount = 0;
          for (var i4 = 0; i4 < rsBlocks.length; i4++) totalDataCount += rsBlocks[i4].dataCount;
          if (buffer.getLengthInBits() <= totalDataCount * 8) break;
        }
      }
      makeImpl(false, getBestMaskPattern());
    };

    return _this;
  };

  // Byte data
  var QR8bitByte = function(data) {
    var _data = data;
    var _this = {};
    _this.mode = QRMode.MODE_8BIT_BYTE;
    _this.getLength = function() { return _data.length; };
    _this.write = function(buffer) {
      for (var i = 0; i < _data.length; i++) buffer.put(_data.charCodeAt(i), 8);
    };
    return _this;
  };

  var QRMode = { MODE_NUMBER:1, MODE_ALPHA_NUM:2, MODE_8BIT_BYTE:4, MODE_KANJI:8 };
  var QRErrorCorrectLevel = { L:1, M:0, Q:3, H:2 };
  var QRMaskPattern = { PATTERN000:0, PATTERN001:1, PATTERN010:2, PATTERN011:3, PATTERN100:4, PATTERN101:5, PATTERN110:6, PATTERN111:7 };

  var QRUtil = (function(){
    var PATTERN_POSITION_TABLE = [[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]];
    var G15 = (1<<10)|(1<<8)|(1<<5)|(1<<4)|(1<<2)|(1<<1)|(1);
    var G18 = (1<<12)|(1<<11)|(1<<10)|(1<<9)|(1<<8)|(1<<5)|(1<<2)|(1);
    var G15_MASK = (1<<14)|(1<<12)|(1<<10)|(1<<4)|(1<<1);
    var _this = {};
    var BCHDigit = function(data){ var digit=0; while(data!=0){ digit++; data>>>=1; } return digit; };
    _this.getBCHTypeInfo = function(data){ var d=data<<10; while(BCHDigit(d)-BCHDigit(G15)>=0){ d ^= (G15 << (BCHDigit(d)-BCHDigit(G15))); } return (data<<10)|d; };
    _this.getBCHTypeNumber = function(data){ var d=data<<12; while(BCHDigit(d)-BCHDigit(G18)>=0){ d ^= (G18 << (BCHDigit(d)-BCHDigit(G18))); } return (data<<12)|d; };
    _this.getPatternPosition = function(typeNumber){ return PATTERN_POSITION_TABLE[typeNumber-1]; };
    _this.getMask = function(maskPattern,i,j){ switch(maskPattern){ case QRMaskPattern.PATTERN000: return (i+j)%2==0; case QRMaskPattern.PATTERN001: return i%2==0; case QRMaskPattern.PATTERN010: return j%3==0; case QRMaskPattern.PATTERN011: return (i+j)%3==0; case QRMaskPattern.PATTERN100: return (Math.floor(i/2)+Math.floor(j/3))%2==0; case QRMaskPattern.PATTERN101: return (i*j)%2+(i*j)%3==0; case QRMaskPattern.PATTERN110: return ((i*j)%2+(i*j)%3)%2==0; case QRMaskPattern.PATTERN111: return ((i*j)%3+(i+j)%2)%2==0; default: throw new Error('bad maskPattern'); } };
    _this.getErrorCorrectPolynomial = function(errorCorrectLength){ var a=QRPolynomial([1],0); for(var i=0;i<errorCorrectLength;i++) a=a.multiply(QRPolynomial([1, QRMath.gexp(i)],0)); return a; };
    _this.getLengthInBits = function(mode,typeNumber){ if(1<=typeNumber && typeNumber<10){ switch(mode){ case QRMode.MODE_NUMBER:return 10; case QRMode.MODE_ALPHA_NUM:return 9; case QRMode.MODE_8BIT_BYTE:return 8; case QRMode.MODE_KANJI:return 8; default: throw new Error('mode:'+mode); } } else if(typeNumber<27){ switch(mode){ case QRMode.MODE_NUMBER:return 12; case QRMode.MODE_ALPHA_NUM:return 11; case QRMode.MODE_8BIT_BYTE:return 16; case QRMode.MODE_KANJI:return 10; default: throw new Error('mode:'+mode); } } else if(typeNumber<41){ switch(mode){ case QRMode.MODE_NUMBER:return 14; case QRMode.MODE_ALPHA_NUM:return 13; case QRMode.MODE_8BIT_BYTE:return 16; case QRMode.MODE_KANJI:return 12; default: throw new Error('mode:'+mode); } } else throw new Error('type:'+typeNumber); };
    _this.getLostPoint = function(qrCode){ var moduleCount = qrCode.getModuleCount(); var lostPoint = 0; for(var row=0; row<moduleCount; row++){ for(var col=0; col<moduleCount; col++){ var sameCount = 0; var dark = qrCode.isDark(row,col); for(var r=-1;r<=1;r++){ if(row+r<0||moduleCount<=row+r) continue; for(var c=-1;c<=1;c++){ if(col+c<0||moduleCount<=col+c) continue; if(r==0&&c==0) continue; if(dark==qrCode.isDark(row+r,col+c)) sameCount++; } } if(sameCount>5) lostPoint += (3 + sameCount - 5); } }
      for(var row2=0; row2<moduleCount-1; row2++){ for(var col2=0; col2<moduleCount-1; col2++){ var count = 0; if(qrCode.isDark(row2,col2)) count++; if(qrCode.isDark(row2+1,col2)) count++; if(qrCode.isDark(row2,col2+1)) count++; if(qrCode.isDark(row2+1,col2+1)) count++; if(count==0 || count==4) lostPoint += 3; } }
      for(var row3=0; row3<moduleCount; row3++){ for(var col3=0; col3<moduleCount-6; col3++){ if(qrCode.isDark(row3,col3) && !qrCode.isDark(row3,col3+1) && qrCode.isDark(row3,col3+2) && qrCode.isDark(row3,col3+3) && qrCode.isDark(row3,col3+4) && !qrCode.isDark(row3,col3+5) && qrCode.isDark(row3,col3+6)) lostPoint += 40; } }
      for(var col4=0; col4<moduleCount; col4++){ for(var row4=0; row4<moduleCount-6; row4++){ if(qrCode.isDark(row4,col4) && !qrCode.isDark(row4+1,col4) && qrCode.isDark(row4+2,col4) && qrCode.isDark(row4+3,col4) && qrCode.isDark(row4+4,col4) && !qrCode.isDark(row4+5,col4) && qrCode.isDark(row4+6,col4)) lostPoint += 40; } }
      var darkCount=0; for(var r2=0;r2<moduleCount;r2++){ for(var c2=0;c2<moduleCount;c2++){ if(qrCode.isDark(r2,c2)) darkCount++; } }
      var ratio = Math.abs(100*darkCount/moduleCount/moduleCount - 50)/5; lostPoint += ratio*10;
      return lostPoint;
    };
    return _this;
  })();

  var QRMath = (function(){ var EXP_TABLE=new Array(256); var LOG_TABLE=new Array(256); for(var i=0;i<8;i++) EXP_TABLE[i]=1<<i; for(var i2=8;i2<256;i2++) EXP_TABLE[i2]=EXP_TABLE[i2-4]^EXP_TABLE[i2-5]^EXP_TABLE[i2-6]^EXP_TABLE[i2-8]; for(var i3=0;i3<255;i3++) LOG_TABLE[EXP_TABLE[i3]]=i3; var _this={}; _this.glog=function(n){ if(n<1) throw new Error('glog('+n+')'); return LOG_TABLE[n]; }; _this.gexp=function(n){ while(n<0) n+=255; while(n>=256) n-=255; return EXP_TABLE[n]; }; return _this;})();

  var QRPolynomial = function(num, shift){ var _num = (function(){ var offset=0; while(offset<num.length && num[offset]==0) offset++; var res=new Array(num.length-offset+shift); for(var i=0;i<num.length-offset;i++) res[i]=num[i+offset]; return res; })(); var _this={}; _this.getAt=function(index){ return _num[index]; }; _this.getLength=function(){ return _num.length; }; _this.multiply=function(e){ var num=new Array(_this.getLength()+e.getLength()-1); for(var i=0;i<_this.getLength();i++){ for(var j=0;j<e.getLength();j++){ num[i+j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i)) + QRMath.glog(e.getAt(j))); } } return QRPolynomial(num,0); }; _this.mod=function(e){ if(_this.getLength()-e.getLength()<0) return _this; var ratio = QRMath.glog(_this.getAt(0)) - QRMath.glog(e.getAt(0)); var num=new Array(_this.getLength()); for(var i=0;i<_this.getLength();i++) num[i]=_this.getAt(i); for(var i2=0;i2<e.getLength();i2++) num[i2] ^= QRMath.gexp(QRMath.glog(e.getAt(i2))+ratio); return QRPolynomial(num,0).mod(e); }; return _this; };

  var QRRSBlock = (function(){ var RS_BLOCK_TABLE = [
    // L
    // M
    // Q
    // H
    [1,26,19],[1,26,16],[1,26,13],[1,26,9],
    [1,44,34],[1,44,28],[1,44,22],[1,44,16],
    [1,70,55],[1,70,44],[2,35,17],[2,35,13],
    [1,100,80],[2,50,32],[2,50,24],[4,25,9],
    [1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],
    [2,86,68],[4,43,27],[4,43,19],[4,43,15],
    [2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],
    [2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],
    [2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],
    [2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],
    [4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],
    [2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],
    [4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],
    [3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],
    [5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12,7,37,13],
    [5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],
    [1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],
    [5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],
    [3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],
    [3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],
    [4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],
    [2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],
    [4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],
    [6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],
    [8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],
    [10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],
    [8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],
    [3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],
    [7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],
    [5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],
    [13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],
    [17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],
    [17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],
    [13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],
    [12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],
    [6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],
    [17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],
    [4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],
    [20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],
    [19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]
  ];
    var QRRSBlock = function(totalCount, dataCount){ var _this={}; _this.totalCount=totalCount; _this.dataCount=dataCount; return _this; };
    var _this={}; _this.getRSBlocks=function(typeNumber,errorCorrectLevel){ var rsBlock = RS_BLOCK_TABLE[(typeNumber-1)*4 + errorCorrectLevel]; var list=[]; for(var i=0;i<rsBlock.length;i+=3){ var count=rsBlock[i]; var total=rsBlock[i+1]; var data=rsBlock[i+2]; for(var j=0;j<count;j++) list.push(QRRSBlock(total,data)); } return list; };
    return _this;
  })();

  var QRBitBuffer = function(){ var _buffer=[]; var _length=0; var _this={}; _this.getBuffer=function(){ return _buffer; }; _this.getAt=function(i){ return ( (_buffer[Math.floor(i/8)] >>> (7 - i%8)) & 1 )==1; }; _this.put=function(num,length){ for(var i=0;i<length;i++){ _this.putBit( ((num >>> (length - i - 1)) & 1)==1 ); } }; _this.getLengthInBits=function(){ return _length; }; _this.putBit=function(bit){ var bufIndex=Math.floor(_length/8); if(_buffer.length<=bufIndex) _buffer.push(0); if(bit) _buffer[bufIndex] |= (0x80 >>> (_length%8)); _length++; }; return _this; };

  var createData = function(typeNumber, errorCorrectLevel, dataList){
    var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
    var buffer = QRBitBuffer();
    for (var i = 0; i < dataList.length; i++) {
      buffer.put(dataList[i].mode, 4);
      buffer.put(dataList[i].getLength(), QRUtil.getLengthInBits(dataList[i].mode, typeNumber));
      dataList[i].write(buffer);
    }
    var totalDataCount = 0;
    for (var i2 = 0; i2 < rsBlocks.length; i2++) totalDataCount += rsBlocks[i2].dataCount;
    if (buffer.getLengthInBits() > totalDataCount * 8) throw new Error('code length overflow.');
    while (buffer.getLengthInBits() + 4 <= totalDataCount * 8) buffer.put(0,4);
    while (buffer.getLengthInBits() % 8 != 0) buffer.putBit(false);
    while (buffer.getLengthInBits() < totalDataCount * 8) {
      buffer.put(PAD0, 8);
      if (buffer.getLengthInBits() >= totalDataCount * 8) break;
      buffer.put(PAD1, 8);
    }
    return createBytes(buffer, rsBlocks);
  };

  var createBytes = function(buffer, rsBlocks){
    var offset = 0; var maxDcCount = 0; var maxEcCount = 0;
    var dcdata = new Array(rsBlocks.length); var ecdata = new Array(rsBlocks.length);
    for (var r = 0; r < rsBlocks.length; r++) {
      var dcCount = rsBlocks[r].dataCount; var ecCount = rsBlocks[r].totalCount - dcCount;
      maxDcCount = Math.max(maxDcCount, dcCount); maxEcCount = Math.max(maxEcCount, ecCount);
      dcdata[r] = new Array(dcCount);
      for (var i = 0; i < dcCount; i++) dcdata[r][i] = 0xff & buffer.getBuffer()[i + offset];
      offset += dcCount;
      var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
      var rawPoly = QRPolynomial(dcdata[r], 0);
      var modPoly = rawPoly.mod(rsPoly);
      ecdata[r] = new Array(ecCount);
      for (var i2 = 0; i2 < ecCount; i2++) ecdata[r][i2] = modPoly.getAt(i2);
    }
    var totalCodeCount = 0; for (var i3 = 0; i3 < rsBlocks.length; i3++) totalCodeCount += rsBlocks[i3].totalCount;
    var data = new Array(totalCodeCount); var index = 0;
    for (var i4 = 0; i4 < maxDcCount; i4++) { for (var r2 = 0; r2 < rsBlocks.length; r2++) { if (i4 < dcdata[r2].length) data[index++] = dcdata[r2][i4]; } }
    for (var i5 = 0; i5 < maxEcCount; i5++) { for (var r3 = 0; r3 < rsBlocks.length; r3++) { if (i5 < ecdata[r3].length) data[index++] = ecdata[r3][i5]; } }
    return data;
  };

  // Public factory
  function qrcode(typeNumber, errorCorrectLevel) { return QRCodeModel(typeNumber, errorCorrectLevel); }

  // Expose helper toCanvas similar to npm qrcode
  function toCanvas(canvas, text, opts) {
    return new Promise(function(resolve, reject){
      try {
        if (!canvas) throw new Error('Canvas required');
        var width = opts && opts.width ? opts.width : 256;
        var margin = opts && typeof opts.margin === 'number' ? opts.margin : 4;
        var qr = qrcode(0, 'M');
        qr.addData(String(text || ''));
        qr.make();
        var count = qr.getModuleCount();
        var c = canvas.getContext('2d');
        var cell = Math.floor((width - margin * 2) / count) || 1;
        var size = cell * count + margin * 2;
        canvas.width = size; canvas.height = size;
        c.fillStyle = '#ffffff';
        c.fillRect(0,0,size,size);
        c.fillStyle = '#000000';
        for (var r=0; r<count; r++) {
          for (var col=0; col<count; col++) {
            if (qr.isDark(r,col)) c.fillRect(margin + col*cell, margin + r*cell, cell, cell);
          }
        }
        resolve(canvas);
      } catch (err) { reject(err); }
    });
  }

  var QRCode = { toCanvas: toCanvas };
  global.QRCode = QRCode;
})(typeof window !== 'undefined' ? window : this);
